\section{Scrambler}
\label{sec:scrambling_algorithms}

	Due to radiation levels inside the detector chamber, the main data processing takes place in a concrete bunker away from the detector.
	To facilitate this, 20 optical links (per module) are used to transfer the data from the front end VELO to the DAQ FPGA.
	When communicating data digitally, the transferring module (TX) and the receiving module (RX) must have synchronised clocks.
	In this case, the GWT serialiser is the TX, and the DAQ is the RX.
	When achieving a synchronised clock, there are two main approaches:

	\begin{easylist}
		\ListProperties(Numbers=R,Margin=0.5cm,Align=fixed,FinalSpace=2em)
		% & Syncinize both the TX and RX from a single central clock - used in I$^2$C communication.
		& Transmit the TX clock with the data to the RX module - used in I$^2$C and SPI communication.
		& Use bit-changes in the data to continuously synchronised the RX clock.
	\end{easylist}

	The former of these options, although widely used in conventional electronics, requires a finely tuned clock accounting for all possible delays.
	The latter, while negating cons of the former, requires data with a high density of transitions to reduce the likelihood of a desynchronisation event.
	Because delays in the data are possible, the latter option has been selected.

	As mentioned, it is necessary to ensure that the data has a large density of transitions before being transmitted from the front-end detector to the DAQ module.
	However, as the majority of super pixel hit maps are empty, the data has a bias towards \textit{`0'}s.
	This reduces the frequency of transitions in the data - increasing the probability of a desynchronisation event.
	It is therefore necessary to scramble the data prior to transmission and descramble the data in the LLI of the DAQ FPGA.
	\par
	Scrambling and later descrambling the data is not a trivial exercise.
	The scrambling (TX) module and descrambling (RX) module must use a synchronised \textit{`key'}, that is used in both the scrambling and descrambling processes.
	In the FPGA, the \textit{`key'} is derived from the previous states of the data.
	There are two methods investigated for generating this \textit{`key'}:

	\begin{description}
		\item[Additive] The \textit{`key'} is generated by evolving the previous \textit{`key'} at each iteration of data using the incoming frame.
		\item[Multiplicative] The  \textit{`key'} is generated from the previous $n$ frames. (Here $n$ is a variable specific to the algorithm).
	\end{description}

	\subsection{Scrambler Options}
	\label{sub:scrambler_options}

		Three scrambling algorithms have been considered:

		\begin{description}
			\item[Additive Scrambler] \hfill \\
				This scrambler was originally implemented and used two sets of two-input XOR logic gates.
				As the name implies, this scrambler used additive key generation which is dependent on all previous input frames since the last reset signal.

			\item[Intermediate Scrambler] \hfill \\
				Created by Karol Hennessy, and deriving its name arbitrarily from the order of consideration, this multiplicative scrambler combines the current and previous frames to generate the \textit{`key'}.
				Therefore, in the event of desynchronisation, only two frames are lost before the \textit{`key'} is automatically recovered.
				This feature alone is a significant improvement over the Additive Scrambler.

			\item[VeloPix Scrambler] \hfill \\
				This is the current implemented scrambling algorithm in the DAQ and VeloPix code.
				Like the Intermediate Scrambler, it uses multiplicative \textit{`key'} generation.
				However, the VeloPix scrambler is compatible with further constraints enforced by the ASIC, including the number of combinational logic operations.
				The Intermediate Scrambler was design purely for simulation purposes and as such does not meet the additional ASIC constraints.
		\end{description}


	\subsection{Cross Checks} % (fold)
	\label{sub:cross_checks}
		The main priority when scrambling data, is ensuring that the data is recoverable.
		For all three scramblers, the algorithm was synthesised in Quartus \cite{ref:quartus} and simulated in Modelsim \cite{ref:modelsim}.
		The aim of synthesising and simulating the scramblers in these programs was to ensure that the design was both physical in terms of on-board logic gates, and to check that the scrambled data was recoverable, respectively.
		\par
		Furthermore, a C++ simulation was created for the three scramblers.
		This simulation had two main purposes;
		firstly to cross check the output of the C++ against the Modelsim simulations;
		secondly to simulate the scrambler over a much larger sample of data as Modelsim simulations are less time efficient.
		In addition to the cross checks, the C++ code allowed for the injection of a desychrnonisation event, in which the \textit{`key'} is lost.
		As expected, the Additive Scrambler was unable to recover any data post desychrnonisation, however the intermediate and VeloPix scramblers both recovered the \textit{`key'} after two frames and continued to decode data.

	% subsection cross_checks (end)

	\subsection{Algorithm Analysis}
	\label{sub:algorithm_analysis}

		For analytical purposes, it is assumed that fully scrambled data is indistinguishable from randomly generated data. 
		For this reason, the three algorithms are not only tested against each other and pre-scrambled simulated QWT data but also randomly generated binary.
		The randomly generated data was created using the Python \textit{`random'} library, selecting a \textit{`0'} or \textit{`1'} with equal probability.
		While the Python \textit{`random'} library is only pseudo-random, on the scale of this application (i.e. $>>$ 100,000 frames), it is sufficient for these purposes.
		\par
		A more mathematically rigorous approach, however, is to evaluate the system abstractly in the framework of statistical physics.
		In this abstraction, the 120 bit frame (with the header and parity removed)  is considered an ensemble; 
		microstates are the particular form of the frames;
		and macroscopic quantities can be calculated by averaging a large number of frames.
		For the analysis outlined in section \ref{subsub:messurements_of_the_algorithms}, predictions will be made using these principles and outlined in section \ref{subsub:statistical_predictions}.
		\par
		In the context of the statistical model, it is reasonable to consider the degree of \textit{`scrambled-ness'} analogous to entropy.	
		This analogy is not dissimilar to the common interpretation of entropy as a measure of disorder. 
		From Boltzmann's equation for entropy,

		\begin{equation}
			S \propto ln(\Omega)
			\label{eqn:boltzman}
		\end{equation}

		where $\Omega$ is the number of microstates associated with the macrostate, we learn that this state of maximum entropy is a macrostate with the maximum number of associated microstates.
		\par
		The entropic argument of Equation~\ref{eqn:boltzman} is not only mathematically founded. 
		For a scramble algorithm to hold for all possible data sets, it must also be capable of outputting all possible permutations. 
		As such, assuming all possible outputs are equally likely, the count of each macroscopic output will be proportional to the number of microstates associated.

		\subsubsection{Measurements of the Algorithms} 
		\label{subsub:messurements_of_the_algorithms}

			To compare the efficiency of the three algorithms in section \ref{sub:scrambler_options}, the algorithms where run over the same input data and compared for the following measures:

			\begin{description}
				\item[Number of Transitions Per Frame] \hfill \\
					This measure counts the total number of bit transitions (i.e. $bit(n) \neq bit(n-1)$) in a 120 bit frame. 
					The header and parity information was not included as they are not scrambled.
					This is an important test as one of the roles of the scrambler is to maximise the number of transitions.

				\item[Common Bit Chain Length] \hfill \\
					One of the downfalls of the `Number of Transitions Per Frame' analysis is that the two hypothetical 20 bit frames,

					\begin{enumerate}[a)]
						\item \textsc{10101010101111111111},
						\item \textsc{10011001100110011001},
					\end{enumerate}

					both with 10 transitions, are considered to be equal. However, (b) is clearly a more suitable output for data transfer as (a) has a large probability of desynchronisation due to the long chains of \textit{`1'}s in the rightmost bits.
					It is therefore also necessary to evaluate the length of common bit chains within the scrambled data as shorter chains are more suitable for data transfer.

				\item[Bit Asymmetry] \hfill \\
					Pre-scramble, the data had a large bias towards \textit{`0'}s due to the majority of the hit maps being empty.
					Scrambled data, via entropic arguments, \textit{should} show zero bias either way.
					Therefore, by investigating how the number of \textit{`1'}s - \textit{`0'}s evolves over many frames, any bias in the scrambler can be found.

			\end{description}	

		\subsubsection{Statistical Predictions} % (fold)
		\label{subsub:statistical_predictions}

			\begin{description}
				\item[Number of Transitions Per Frame] \hfill \\
					
					Consider a particle in a symmetric, discrete time-dependent, two state system,

					\begin{equation}
						p_0(t) = p_1(t) = 0.5 \quad : \quad \forall\ t \in \mathbb{N},
					\end{equation}

					At each time iteration,

					\begin{equation}
						p_{i \to j}(t) = 0.5 \quad : \quad i,j = [0\ 1], \quad \forall\ t \in \mathbb{N}.
					\end{equation}

					However, assuming zero bias and detailed balance, as $p_{1 \to 0}(t)$ is equal in both probability and importance to $p_{0 \to 1}(t)$, the probability of a bit change shall henceforth be refereed to as $p_{\tau}(t)$.
					\par
					Over an $n$ step process, analogous to an $n$ bit frame, the probability distribution of the number of transitions $N_\tau$ is given by Binomial statistics,

					\begin{equation}
						f(N_{\tau}) = \frac{n!}{N_{\tau}!(n-N_{\tau})!}\ p^{N_{\tau}}\ (1 - p)^{n-N_{\tau}}
					\end{equation}

					Simplified for the special case $p = p_{\tau} = 0.5$,

					\begin{equation}
						f_{\tau}(N_{\tau}) = \frac{n!}{N_{\tau}!(n-N_{\tau})!}\ (p_{\tau})^{n}
						\label{eqn:transition_propability_dencity}
					\end{equation}

					For $n = 120$, we can calculate,

					\begin{equation}
						<N_\tau>^{Binomial} \ = \sum_{N_{\tau}=0}^{n-1} N_{\tau}\ f(N_{\tau}) = n\ p_{\tau} = 60
						\label{eqn:tansition_expectation}
					\end{equation}

					\begin{equation}
						\sigma_{N_\tau}^{Binomial} = \sqrt{ n\ p_{\tau}^2} = 5.48
					\end{equation}

					Furthermore, when considering the entropic argument of equation \ref{eqn:boltzman}, the number of microstates corresponding to each macrostate $N_\tau$ can be related to equation \ref{eqn:transition_propability_dencity},

					\begin{equation}
						\Omega_\tau \sim \frac{n!}{N_{\tau}!(n-N_{\tau})!}
					\end{equation}

					\begin{equation}
						<N_\tau>^{Entropic} = MAX[S_\tau] = MAX[\Omega_\tau]
					\end{equation}

					This can be numerically solved,

					\begin{equation}
						<N_\tau>^{Entropic}\ = 60
						\label{eqn:n_t_entropic}
					\end{equation}

					While the result of equation \ref{eqn:n_t_entropic} does not contibute anything new, it is important as a \textit{`sanity check'}.
					Because the system can be described as in section \ref{sub:algorithm_analysis}, it would indicate a problem in the theoretical framework if the result did not match.


				\item[Common Bit Chain Length] \hfill \\
					
					The probability of a chain of length $n$ is,

					\begin{equation}
						p_n = p_1(1 - p_\tau)^{n-1}, \quad : \quad n \in \mathbb{N}, \quad n > 1
					\end{equation}

					where $p_1$ is the number of chains of length 1. 
					As $p_1 = N_0 (1 -p_\tau)$, where $N_0$ is the total number of chains,

					\begin{equation}
						\frac{N_n}{N_0} = (1 - p_\tau)^n, \quad : \quad n \in \mathbb{N}, \quad n > 1
					\end{equation}

					where $N_n$ is the number of chains of length $n$.
					Taking the logarithm of both sides,

					\begin{align}
						log\left(\frac{N_n}{N_0}\right) &= n\ log(1 - p_\tau), \nonumber \\
 						log(N_n) &= n\  log(1 - p_\tau) + log(N_0).
 					\end{align}

					Therefore, for a graph of $log(N_n)$ against $n$ for a large sample of data, the gradient would be $log(1 - p_\tau)$.
					In this case, as $p_\tau = 0.5$, 

					\begin{equation}
						log(1 - p_\tau) = -0.30\ .
						\label{eqn:log_chain_length_gradient}			
					\end{equation}

				\item[Bit Asymmetry] \hfill \\
					
					$A_{1,0}$, the asymmetry of \textit{`1'}s and \textit{`0'}s is defined as,

					\begin{equation}
						A_{1,0} = N_1 - N_0,
						\label{eqn:a_def}
					\end{equation}

					where $N_1$ and $N_0$ are the number of \textit{`1'}s and \textit{`0'}s respectively.
					We can consider the evolution of $A_{1,0}$ with frame $t$ of size $n$ as a stochastic iterative map with zero deterministic growth \cite{ref:stockastic_physics},

					\begin{equation}
						A_{1,0}(nt + n\ \Delta t) = A_{1,0}(nt) + \mathcal{N}(nt).
					\end{equation}

					Where $\mathcal{N}$ is an independant random variable picked from a gaussian distribution. While $A_{1,0}(t) \in \mathbb{Z}$, in the limit of large $nt$ we can approximate that $A_{1,0}$ is continous. 
					\par
					If we consider the moments of $A_{1,0}$,

					\begin{align}
						\label{eqn:A_moment1}
						<A_{1,0}(nt = M\ n\ \Delta t)> & = \sum_{m = 0}^{M -1}  \mathcal{N}(m\ n\ \Delta t), \\
						\label{eqn:A_moment2}
						<A_{1,0}(nt = M\ n\ \Delta t)^2> & = \sum_{m=0}^{M-1} \sum_{m'=0}^{M-1}  \mathcal{N}(m\ n\ \Delta t) \mathcal{N}(m'\ n\ \Delta t)\ \delta_{mm'} \nonumber \\
						&= \sum_{m=0}^{M-1} < \mathcal{N}(m\ n\ \Delta t)^2 >.
					\end{align}

					Clearly, in Equation \ref{eqn:A_moment1}, $<A_{1,0}> = 0$. In Equation \ref{eqn:A_moment2}, we assume the variance is of form $(n\ \Delta t)^\alpha$ \cite{ref:stockastic_physics}. Then,

					\begin{equation}
						<A_{1,0}(nt = M\ n\ \Delta t)^2>\ = M (n\ \Delta t)^\alpha.
						\label{eqn:A_moment3}
					\end{equation}

					Running the analysis over the frames $t = 0$ to $t_f$, the number of bits sampled is $M = {t_f / n\ \Delta t}$. Substituting this into Equation \ref{eqn:A_moment3},

					\begin{equation}
						<A_{1,0}(nt = M\ n\ \Delta t)^2>\ = t_f\ (n\ \Delta t)^{\alpha -1}.
					\end{equation}

					Considering the three cases of $\alpha$ in the approximation of continous $n \Delta t$:
					
					\vspace{1em}

					\begin{easylist}[itemize]
						% \ListProperties{Margin=2cm,Align=fixed,FinalSpace=2em}
						& $\bm{\alpha > 1}$: Here $A_{1,0} \to 0$ as $\Delta t \to 0$.
						& $\bm{\alpha < 1}$: Here $A_{1,0} \to \infty$ as $\Delta t \to 0$.
						& $\bm{\alpha = 1}$: This is the only sensible choice.
					\end{easylist}
					
					\vspace{1em}

					With $\alpha =1$,

					\begin{equation}
						<A_{1,0}(nt = M\ n\ \Delta t)^2> = M (n\ \Delta t).
					\end{equation}

					And thus,

					\begin{equation}
						\sigma_{A_{1,0}} = \sqrt{<A_{1,0}^2> - <A_{1,0}>^2} = \sqrt{<A_{1,0}^2>} = \sqrt{n\ \Delta t}.
					\end{equation}

			\end{description}	

		\subsubsection{Results of Analysis}
		\label{subsub:algorithm_results}
			\begin{SCfigure}%[ht]
				\centering
				\includegraphics[width=0.7\textwidth]{Transition_Histogram_update}
				\caption{Results of the \textit{`Number of Transitions Per Frame'} analysis. The results for the Random Data, Intermediate Scrambler and VeloPix Scrambler overlap.}
				\label{fig:transitions_per_frame}
			\end{SCfigure}
			\par
			\begin{SCfigure}%[ht]
				\centering
				\includegraphics[width=0.7\textwidth]{Chain_length}
				\caption{Results of the \textit{`Common Bit Chain Length'} analysis. The results for the Random Data, Additive Scrambler, Intermediate Scrambler and VeloPix Scrambler overlap.}
				\label{fig:chain_length}
			\end{SCfigure}
			\par
			\begin{figure}[ht]
				\centering
				\includegraphics[width=1\textwidth]{Balance_graph_cropped}
				\caption{The results of the \textit{`Bit Asymetry'} analysis.}
				\label{fig:bit_asym}
			\end{figure}

			The results from the \textit{`Number of Transitions Per Frame'} analysis, shown in Figure~\ref{fig:transitions_per_frame}, show a strong similarity between the Intermediate and VeloPix Scramblers with the randomly generated data. 
			These results are within 1\% agreement with the theoretical predictions for $<N_\tau> = 60$ and $\sigma_{N_\tau} = 5.48$, made in Section~\ref{subsub:statistical_predictions}. 
			The remarkable consistency between the theoretical predictions and the randomly generated data provides confidence in both the theory, and the scrambled nature of the Intermediate and VeloPix scrambler outputs.
			\par
			For the \textit{`Common Bit Chain Length'} analysis all three scramblers; the random data, and the theoretical predictions are consistent to within 1\%. 
			Comparing the results for the Additive Scrambler, it is shown that while the frequency of longer chains is consistent with random data, the variance of transitions is larger than predicted. 
			Thus, the long and short trains are more locally clustered. 
			\par
			The \textit{`Bit Asymmetry'} of each scrambler, shown in Figure~\ref{fig:bit_asym}, is consistent with the theoretical prediction. 
			The deviation of $A_{1,0}$ for the predicted mean of 0 is fully consistent with stochastic noise. 
			The random data also shows consistency. 
			This gives confidence in the assumptions made in Section~\ref{subsub:statistical_predictions}.		
 			% \par		
 			% One notible feature of Figure\ref{fig:bit_asym} is the steap grandient of the additive scrambler a $t \sim 6.10^6$.		
 			% However, as the data stays within the theoretical limits and the \textit{`drop'} is of approximatly $\Delta A_{1,0} \sim 60.10^3$ over the range $n\ \Delta t \sim 1.2.10^8$ it would be difficult to construnct any argument claiming that this feature is of statistically significance.

	\subsection{Conclusion}

		\begin{table}[h]		
 			\centering		
 			\begin{TAB}(r)[7pt]{l|cc:cc}{c|c:ccc:cc}		
 							           & $<N_\tau>$ & $\sigma_{N_\tau}$ & Gradient  	& $p_\tau$    \\		
 				GQT data  		       & 54      	& 6.63           	& -0.268 		& 0.460 \\		
 				Additive Scrambler     & 60      	& 7.35           	& -0.305 		& 0.504 \\		
 				Intermediate Scrambler & 60      	& 5.45           	& -0.305 		& 0.504 \\		
 				Velopix Scrambler      & 60      	& 5.46           	& -0.305 		& 0.504 \\		
 				Random Data            & 60      	& 5.45           	& -0.305 		& 0.504 \\		
 				Theoretical Prediction & 60      	& 5.48           	& -0.3 			& 0.5   			
 			\end{TAB}		
 			\caption{The combined results of the algorithum analysis.}		
 			\label{tab:comb_results}		
 		\end{table}		
 		
 		The consistency of random data and the theoretical predictions justifies the assumptions and approximations made in Section~\ref{sub:algorithm_analysis} and Section~\ref{subsub:statistical_predictions}. 
 		Furthermore, the confirmation of the statistical model allows for accurate comparisons to be made from predicted values and their measured counterparts.		
 		\par		
 		The Additive Scrambler, while consistent with the \textit{`Chain Length'} and \textit{`Bit Asymmetry'} analysis, has a variance in the transition frequency that leads to the conclusion that long and short chains are locally clustered. 		
 		This is not ideal for data transfer. 		
 		Many sequential long chains increase the probability of TX-RX clock desynchronisation. 		
 		Furthermore, the additive scrambler will not recover from this loss of synchronisation, as the \textit{`key'} will never be recovered without a common reset signal.		
 		\par		
 		The Intermediate Scrambler produced an output consistent with random data. 		
 		This makes the algorithm suitable for data transfer.		
 		As already mentioned, however, the scrambler is designed for computer simulation.		
 		As such, it is not suitable for implementation as it does not meet the addition requirements of the ASIC.		
 		\par		
 		The VeloPix Scrambler, like the Intermediate Scrambler, produces a statistically scrambled output.		
 		Furthermore, the algorithm is in line with the additional requirements of the ASIC.		
 		As such, it is ideal for implementation, and hence is currently the choice algorithm for use in the 2019 VELO upgrade.







